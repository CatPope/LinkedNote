{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Structure and Repositories",
        "description": "Initialize the project with the defined file structure for both the Electron frontend and FastAPI backend. Set up the initial repository.",
        "details": "Create the root directory `link-ai-summarizer/` with subdirectories `electron-app/` and `backend/`. Initialize basic package.json for Electron and requirements.txt for FastAPI.",
        "testStrategy": "Verify that the directory structure matches the PRD's `File Structure` section and that initial dependency files are present.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Set Up User Database Schema",
            "description": "Create the necessary database tables to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "The schema should include a `users` table with columns for `id` (primary key), `username` (unique), `email` (unique), `password_hash`, `created_at`, and `updated_at`. Use a database migration tool to manage schema changes.",
            "status": "done",
            "testStrategy": "Verify the migration runs successfully without errors. Manually inspect the database schema to confirm all tables, columns, and constraints (e.g., unique, not null) are created as specified."
          },
          {
            "id": 2,
            "title": "Implement User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., `POST /api/auth/register`) that allows new users to create an account.",
            "dependencies": [],
            "details": "The endpoint should accept a username, email, and password. It must validate the input (e.g., check for existing username/email, enforce password complexity). Hash the password using a strong algorithm like bcrypt before storing it in the database. Return a success message or user object upon successful registration.",
            "status": "done",
            "testStrategy": "Write unit tests to validate input handling (valid, invalid, duplicate data). Write an integration test to simulate a POST request and verify that a new user record is created in the database with a correctly hashed password and a 201 status code is returned."
          },
          {
            "id": 3,
            "title": "Implement User Login and JWT Generation",
            "description": "Create an API endpoint (e.g., `POST /api/auth/login`) for users to authenticate and receive an access token.",
            "dependencies": [],
            "details": "The endpoint should accept a username/email and a password. It will verify the credentials by comparing the provided password with the stored hash. Upon successful authentication, generate a JSON Web Token (JWT) containing the user ID and an expiration date. The JWT should be signed with a secret key stored in environment variables.",
            "status": "done",
            "testStrategy": "Write unit tests for the password verification logic. Write integration tests for the login endpoint with both valid and invalid credentials. Verify that a valid JWT is returned in the response body on successful login and that a 401 Unauthorized error is returned for failed attempts."
          },
          {
            "id": 4,
            "title": "Develop Authentication Middleware for Protected Routes",
            "description": "Implement middleware that can be applied to API routes to ensure they are only accessible by authenticated users.",
            "dependencies": [],
            "details": "The middleware should extract the JWT from the `Authorization` header (e.g., `Bearer <token>`). It must then validate the token's signature and check its expiration. If the token is valid, the user's information (e.g., user ID) should be attached to the request object for use by subsequent handlers. If the token is invalid or missing, the middleware should return a 401 Unauthorized error.",
            "status": "done",
            "testStrategy": "Write integration tests for a sample protected endpoint. Test cases should include requests with a valid token, an invalid/expired token, a malformed token, and no token, verifying the correct HTTP status code (200 or 401) is returned for each case."
          }
        ]
      },
      {
        "id": 2,
        "title": "Phase 1: Implement Electron System Tray Integration",
        "description": "Create the core Electron application that runs persistently in the system tray with a basic icon and right-click menu.",
        "details": "The application should launch minimized to the system tray. A right-click on the icon should show a basic menu (e.g., 'Settings', 'Quit'). This task focuses on the native OS integration, not the UI windows.",
        "testStrategy": "Run the application on Windows, macOS, and Linux to confirm the tray icon appears and the context menu functions correctly.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Electron 프로젝트 초기화",
            "description": "Electron 프로젝트를 설정하고 필요한 종속성을 설치합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 2,
            "title": "기본 Electron 창 생성",
            "description": "Electron 애플리케이션의 기본 창을 생성합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 3,
            "title": "시스템 트레이 아이콘 구현",
            "description": "시스템 트레이에 아이콘을 표시하고 기본 이미지를 설정합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 4,
            "title": "트레이 메뉴 구현",
            "description": "트레이 아이콘을 마우스 오른쪽 버튼으로 클릭했을 때 나타나는 메뉴를 구현합니다 (예: \"설정\", \"종료\").",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          },
          {
            "id": 5,
            "title": "애플리케이션 시작 시 트레이로 최소화",
            "description": "애플리케이션이 시작될 때 창이 아닌 트레이로 최소화되도록 설정합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 2
          }
        ]
      },
      {
        "id": 3,
        "title": "Phase 1: Implement Automatic Clipboard Monitoring",
        "description": "Develop the functionality within the Electron app to continuously monitor the system clipboard for web URLs.",
        "details": "Use Electron's clipboard API to detect strings matching http/https patterns. This should run in the background as part of the main process. Performance should be optimized to have less than 0.5s detection time.",
        "testStrategy": "Copy various URLs and non-URL text from different applications (browser, Slack, text editor) and verify that only valid URLs are detected by the application's logs.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "클립보드 모니터링 모듈 생성",
            "description": "Electron의 `clipboard` API를 사용하여 클립보드 변경을 감지하는 모듈을 생성합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 2,
            "title": "URL 유효성 검사 로직 구현",
            "description": "클립보드에서 읽어온 텍스트가 유효한 웹 URL인지 확인하는 로직을 구현합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 3,
            "title": "URL 감지 시 이벤트 발생 및 로깅",
            "description": "유효한 URL이 감지되면 특정 이벤트를 발생시키고, 감지된 URL을 로깅합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          },
          {
            "id": 4,
            "title": "클립보드 모니터링 백그라운드 실행 설정",
            "description": "클립보드 모니터링이 Electron 앱의 메인 프로세스에서 백그라운드로 지속적으로 실행되도록 설정합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 3
          }
        ]
      },
      {
        "id": 4,
        "title": "Phase 1: Implement System Tray Notifications",
        "description": "Trigger a native OS notification when a valid URL is detected on the clipboard.",
        "details": "Upon URL detection from Task 3, use Electron's Notification API to display a system tray notification for 3 seconds. The notification should be clickable.",
        "testStrategy": "Copy a URL and confirm a native OS notification appears. Clicking the notification should trigger a logged event.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "알림 모듈 생성",
            "description": "Electron의 `Notification` API를 사용하여 알림을 표시하는 모듈을 생성합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 2,
            "title": "알림 표시 로직 구현",
            "description": "URL 감지 이벤트에 반응하여 알림을 표시하는 로직을 구현합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          },
          {
            "id": 3,
            "title": "알림 클릭 이벤트 처리",
            "description": "알림 클릭 시 특정 동작을 수행하는 로직을 구현합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 4
          }
        ]
      },
      {
        "id": 5,
        "title": "Phase 1: Setup FastAPI Backend with /summarize Endpoint",
        "description": "Create the local Python FastAPI server running on port 8000 with a single `/api/summarize` endpoint.",
        "details": "The endpoint should accept a POST request with a 'url' and 'mode'. Initially, it can return a hardcoded or mock summary response. Include basic error handling for invalid requests.",
        "testStrategy": "Send a POST request to `http://localhost:8000/api/summarize` using a tool like curl or Postman and verify it returns a valid JSON response.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "/summarize 엔드포인트 정의",
            "description": "`backend/api/summarize.py` 파일을 생성하여 `/api/summarize` 엔드포인트를 정의합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 2,
            "title": "요약 요청 스키마 정의",
            "description": "`backend/schemas/summary.py` 파일을 생성하여 요약 요청 및 응답에 대한 Pydantic 스키마를 정의합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 3,
            "title": "모의 요약 로직 구현",
            "description": "`backend/services/summarizer.py` 파일을 생성하여 초기에는 하드코딩된 또는 모의 요약 응답을 반환하는 로직을 구현합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 4,
            "title": "main.py에 라우터 포함",
            "description": "`main.py`에서 새로 생성된 요약 라우터를 포함합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          }
        ]
      },
      {
        "id": 6,
        "title": "Phase 1: Implement Web Content Scraper",
        "description": "Build the web scraping logic using BeautifulSoup4 and requests to extract the main text content from a given URL.",
        "details": "The scraper should be a module within the backend. It needs to handle basic HTML structures to find article text, ignoring navigation, ads, and footers. Implement a 5-second timeout and graceful error handling for failed requests or parsing errors.",
        "testStrategy": "Test the scraper with several article URLs and verify that it extracts the primary text content successfully.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "스크래퍼 모듈 생성",
            "description": "`backend/services/scraper.py` 파일을 생성하여 웹 페이지에서 주요 텍스트 콘텐츠를 추출하는 로직을 구현합니다.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 6
          },
          {
            "id": 2,
            "title": "requests 및 BeautifulSoup4 설치",
            "description": "웹 요청 및 HTML 파싱을 위한 라이브러리(`requests`, `BeautifulSoup4`)를 설치합니다.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 6
          },
          {
            "id": 3,
            "title": "URL 콘텐츠 가져오기",
            "description": "주어진 URL에서 HTML 콘텐츠를 가져오는 함수를 구현합니다.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 6
          },
          {
            "id": 4,
            "title": "주요 텍스트 추출",
            "description": "HTML에서 기사 본문과 같은 주요 텍스트 콘텐츠를 식별하고 추출하는 로직을 구현합니다.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 6
          },
          {
            "id": 5,
            "title": "오류 처리 및 타임아웃",
            "description": "요청 실패 또는 파싱 오류에 대한 적절한 오류 처리와 타임아웃을 구현합니다.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 6
          }
        ]
      },
      {
        "id": 7,
        "title": "Phase 2: Integrate OpenAI API for Summarization",
        "description": "Connect the FastAPI backend to the OpenAI API to generate summaries from scraped web content.",
        "details": "Implement the logic in `services/summarizer.py` to send scraped content to OpenAI. Use the predefined prompts for 'summary', 'tags', and 'full'. Handle API errors, such as invalid keys or rate limits.",
        "testStrategy": "Call the `/api/summarize` endpoint with a valid URL and API key. Verify that it returns a summary generated by OpenAI.",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the database schema required for storing user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Use a relational database like PostgreSQL. Create a 'users' table with columns: id (UUID, primary key), email (VARCHAR, unique, not null), password_hash (VARCHAR, not null), created_at (TIMESTAMP), updated_at (TIMESTAMP).",
            "status": "pending",
            "testStrategy": "Verify the table and columns are created correctly using a database inspection tool. Write a migration script and test its up and down states. Manually insert a record to ensure constraints are enforced."
          },
          {
            "id": 2,
            "title": "Implement User Registration Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/auth/register) to allow new users to sign up for an account.",
            "dependencies": [],
            "details": "The endpoint should accept an email and password. Validate the input data (e.g., email format, password strength). Hash the password using a strong algorithm like bcrypt before storing it in the database. Return a success message and user ID upon successful registration.",
            "status": "pending",
            "testStrategy": "Write an integration test that sends a POST request with valid user data and asserts a 201 Created response. Test edge cases like duplicate emails (expect 409 Conflict) and invalid input (expect 400 Bad Request)."
          },
          {
            "id": 3,
            "title": "Implement User Login Endpoint and JWT Generation",
            "description": "Create a public API endpoint (e.g., POST /api/auth/login) for users to authenticate and receive an access token.",
            "dependencies": [],
            "details": "The endpoint should accept an email and password. Find the user by email, then compare the provided password with the stored hash. If valid, generate a JSON Web Token (JWT) containing the user ID and an expiration date. Return the JWT to the client.",
            "status": "pending",
            "testStrategy": "Write integration tests that attempt to log in with correct credentials (assert 200 OK and a valid JWT), incorrect passwords (assert 401 Unauthorized), and non-existent emails (assert 401 Unauthorized)."
          },
          {
            "id": 4,
            "title": "Create Authentication Middleware for Protected Routes",
            "description": "Develop middleware to verify the JWT on incoming requests to secure specific API endpoints.",
            "dependencies": [],
            "details": "The middleware should extract the JWT from the 'Authorization: Bearer <token>' header. It must verify the token's signature and check for expiration. If valid, decode the payload and attach the user's identity to the request context. If invalid, it must return a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Create a protected test endpoint. Write unit tests for the middleware logic. Write integration tests that call the protected endpoint without a token, with an invalid/expired token (expect 401), and with a valid token (expect 200 OK)."
          },
          {
            "id": 5,
            "title": "Implement Protected 'Get User Profile' Endpoint",
            "description": "Create a protected endpoint (e.g., GET /api/users/me) that returns the profile information of the currently authenticated user.",
            "dependencies": [],
            "details": "Apply the authentication middleware to this route. The route handler should access the user identity from the request context (populated by the middleware) and retrieve the corresponding user's data from the database. Return a sanitized user object, omitting sensitive fields like the password hash.",
            "status": "pending",
            "testStrategy": "Write an integration test that first logs in a user to get a JWT, then uses that JWT to make a request to the /api/users/me endpoint. Assert that the response is 200 OK and contains the correct user's data (e.g., email, id) but not the password hash."
          }
        ]
      },
      {
        "id": 8,
        "title": "Phase 2: Create UI for Interaction and Results",
        "description": "Build the two primary UI windows: the 300x200px popup for mode selection and the 600x400px window for displaying results.",
        "details": "Clicking the notification (from Task 4) opens the selection popup. After clicking 'Summarize', a loading indicator is shown, and then the results appear in the new, larger window. The windows should have fixed dimensions.",
        "testStrategy": "Trigger the user flow and verify that the correct windows appear with the specified dimensions and that the UI is responsive.",
        "priority": "medium",
        "dependencies": [
          4,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Authentication Database Schema",
            "description": "Create the necessary database tables to store user information, including credentials, roles, and personal details.",
            "dependencies": [],
            "details": "Define a 'users' table with columns for id, username, email, hashed_password, created_at, and updated_at. Use a database migration tool to version the schema. Consider adding tables for 'roles' and 'user_roles' for future role-based access control.",
            "status": "pending",
            "testStrategy": "Run the migration script against a test database. Manually inspect the created tables and columns to ensure they match the design specifications. Verify constraints like 'unique' on the email column."
          },
          {
            "id": 2,
            "title": "Implement Secure Password Hashing Service",
            "description": "Create a reusable module/service for securely hashing and verifying user passwords to prevent plain-text storage.",
            "dependencies": [],
            "details": "Use a strong, adaptive hashing algorithm like bcrypt or Argon2. The service should expose two main functions: one to hash a plain-text password and another to compare a plain-text password against an existing hash.",
            "status": "pending",
            "testStrategy": "Write unit tests to confirm that the hashing function produces a valid hash and the verification function correctly identifies both matching and non-matching passwords. Ensure two hashes of the same password are not identical due to salting."
          },
          {
            "id": 3,
            "title": "Develop User Registration API Endpoint",
            "description": "Create the backend API endpoint (e.g., POST /api/auth/register) that allows new users to create an account.",
            "dependencies": [],
            "details": "The endpoint should accept user details (e.g., username, email, password). It must validate the input, check for existing users with the same email/username, use the password hashing service to hash the password, and save the new user record to the database.",
            "status": "pending",
            "testStrategy": "Use an API testing tool like Postman to test successful registration, registration with a duplicate email, and registration with invalid data (e.g., weak password, invalid email format). Verify the database record shows a hashed password."
          },
          {
            "id": 4,
            "title": "Develop User Login API Endpoint and JWT Generation",
            "description": "Create the backend API endpoint (e.g., POST /api/auth/login) for users to sign in and receive an authentication token.",
            "dependencies": [],
            "details": "The endpoint will accept user credentials, find the user in the database, use the password hashing service to verify the password, and if successful, generate a JSON Web Token (JWT) containing user identifiers (e.g., user ID, role). The JWT is returned to the client.",
            "status": "pending",
            "testStrategy": "Write integration tests for successful login with correct credentials, failed login with an incorrect password, and failed login for a non-existent user. Verify the structure and payload of the returned JWT."
          },
          {
            "id": 5,
            "title": "Implement API Middleware for Route Protection",
            "description": "Create backend middleware to protect specific API routes, ensuring they are only accessible by authenticated users.",
            "dependencies": [],
            "details": "The middleware will extract the JWT from the 'Authorization' header. It will verify the token's signature and expiration. If valid, it will attach the user's information to the request object and pass control to the next handler. If invalid, it will return a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Create a test-protected endpoint. Write integration tests to access it with a valid token (should succeed), without a token (should fail), and with an invalid or expired token (should fail)."
          },
          {
            "id": 6,
            "title": "Create Frontend Registration Form Component",
            "description": "Build the UI component for the user registration page, including input fields, validation, and form submission logic.",
            "dependencies": [],
            "details": "The form should have fields for username, email, password, and password confirmation. Implement client-side validation for input formats and password strength. On submission, it should call the registration API and handle success or error responses.",
            "status": "pending",
            "testStrategy": "Manual end-to-end testing: fill out and submit the form, checking for correct API calls in the browser's network tab. Write component tests to verify form validation logic and state management. Test UI responsiveness."
          },
          {
            "id": 7,
            "title": "Create Frontend Login Form and Token Management",
            "description": "Build the UI for the login page and implement client-side logic to handle the authentication token.",
            "dependencies": [],
            "details": "The form should have fields for email and password. On successful login, the received JWT must be securely stored on the client (e.g., in an HttpOnly cookie or local storage). Subsequent API requests to protected routes must include this token.",
            "status": "pending",
            "testStrategy": "End-to-end testing: log in successfully and verify the token is stored. Navigate to a protected page to ensure access is granted. Log out and verify the token is cleared and access to the protected page is denied."
          }
        ]
      },
      {
        "id": 9,
        "title": "Phase 2: Automatically Copy Results to Clipboard",
        "description": "Implement the feature to automatically copy the generated summary text to the system clipboard upon successful generation.",
        "details": "Once the result is displayed in the results window, the content should be simultaneously written to the user's clipboard for immediate pasting.",
        "testStrategy": "Generate a summary and immediately try to paste the content into a text editor. Verify the pasted content matches the summary.",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a secure API endpoint for new user registration. This includes input validation, password hashing, and storing user data in the database.",
            "dependencies": [],
            "details": "Endpoint: POST /api/auth/register. Request body should include username, email, and password. Use bcrypt for password hashing. Validate that email and username are unique. On success, return a 201 Created status. On failure, return appropriate 4xx error codes (e.g., 400 for invalid input, 409 for duplicate user).",
            "status": "pending",
            "testStrategy": "Write unit tests for the validation logic (email format, password strength). Create integration tests to cover successful registration, registration with duplicate credentials, and registration with invalid data. Verify that passwords are correctly hashed in the database."
          },
          {
            "id": 2,
            "title": "Implement User Login and JWT Generation",
            "description": "Build the API endpoint for user authentication. It should verify user credentials and, upon successful authentication, generate and return a JSON Web Token (JWT).",
            "dependencies": [],
            "details": "Endpoint: POST /api/auth/login. Request body should include email and password. Find the user by email, then use bcrypt.compare to verify the password against the stored hash. If valid, generate a JWT containing the user ID and role, signed with a secret key. The token should have a defined expiration time.",
            "status": "pending",
            "testStrategy": "Write integration tests for the login endpoint. Test successful login with valid credentials, failed login with an incorrect password, and failed login for a non-existent user. Verify the structure and signature of the returned JWT. Ensure a 401 Unauthorized status is returned for failed attempts."
          }
        ]
      },
      {
        "id": 10,
        "title": "Phase 2: Create Settings Window for API Key",
        "description": "Develop the settings window where users can input and save their OpenAI API key.",
        "details": "The window is accessed via the system tray menu. It should contain a single input field for the API key and a 'Save' button. For this phase, the key can be stored unencrypted in a local file.",
        "testStrategy": "Open the settings window, enter a key, and click save. Restart the app and verify the key is persisted (e.g., in a config file).",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Set Up User Authentication Database Schema",
            "description": "Create the necessary database tables and columns to store user information, including credentials and session data.",
            "dependencies": [],
            "details": "The `users` table should include columns for `id` (primary key), `email` (unique), `password_hash` (string), `created_at`, and `updated_at`. Use a database migration tool to manage schema changes and ensure version control.",
            "status": "pending",
            "testStrategy": "Verify the migration script runs successfully against a test database. Manually inspect the schema to confirm all tables, columns, and constraints (e.g., unique, not null) are created as specified."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., `POST /api/register`) that allows new users to create an account.",
            "dependencies": [],
            "details": "The endpoint must validate incoming data (e.g., valid email format, password complexity). It should check for existing users to prevent duplicate emails. Use a strong hashing algorithm like bcrypt to hash the password before storing it in the database. Return a 201 status code on success.",
            "status": "pending",
            "testStrategy": "Write unit tests for the validation logic. Write integration tests to confirm a new user is created in the database with a correctly hashed password. Test failure cases, such as submitting a duplicate email or invalid data, ensuring correct error codes are returned."
          },
          {
            "id": 3,
            "title": "Develop User Login API Endpoint and Token Generation",
            "description": "Create an API endpoint (e.g., `POST /api/login`) for users to authenticate and receive a session token.",
            "dependencies": [],
            "details": "The endpoint should accept an email and password. It must find the user by email and securely compare the provided password with the stored hash. Upon successful authentication, generate a secure JSON Web Token (JWT) with a reasonable expiration time and return it to the client.",
            "status": "pending",
            "testStrategy": "Write integration tests for successful login attempts, verifying a valid JWT is returned. Test failed login attempts with incorrect passwords or non-existent emails, ensuring a 401 Unauthorized status is returned. Unit test the JWT generation and password comparison logic separately."
          },
          {
            "id": 4,
            "title": "Implement Authentication Middleware for Protected Routes",
            "description": "Create middleware to verify the JWT on incoming requests to protected API endpoints, denying access to unauthenticated users.",
            "dependencies": [],
            "details": "The middleware should extract the JWT from the `Authorization` header. It must validate the token's signature and expiration. If valid, attach the user's identity to the request context for use in protected route handlers. If invalid, it must immediately respond with a 401 or 403 error.",
            "status": "pending",
            "testStrategy": "Create a sample protected endpoint. Write integration tests that call this endpoint with a valid token, an expired token, a malformed token, and no token. Assert that access is correctly granted or denied in each scenario."
          }
        ]
      },
      {
        "id": 11,
        "title": "Phase 3: Setup SQLite Database and Schema",
        "description": "Initialize the local SQLite database and create the `users` and `summaries` tables according to the PRD's data models.",
        "details": "The database file should be stored locally. Implement the schema as defined: `users(id, openai_api_key, created_at)` and `summaries(id, url, mode, content, created_at)`.",
        "testStrategy": "Verify the database file is created on first run and that the tables exist with the correct columns and types.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema and Model",
            "description": "Create the database table to store user information and define the corresponding application model. The table should include fields for ID, email, hashed password, and timestamps.",
            "dependencies": [],
            "details": "Use a migration tool to create a 'users' table with the following columns: `id` (primary key, auto-incrementing), `email` (unique, string), `password_hash` (string), `created_at` (timestamp), `updated_at` (timestamp). Create a `User` model in the application's ORM that maps to this table.",
            "status": "pending",
            "testStrategy": "Run database migrations and verify the 'users' table is created with the correct schema. Write a unit test to create and retrieve a user instance using the User model to ensure the ORM mapping is correct."
          },
          {
            "id": 2,
            "title": "Create User Registration API Endpoint",
            "description": "Develop a public API endpoint (e.g., POST /api/auth/register) that allows new users to create an account. The endpoint should validate input, hash the password, and store the new user in the database.",
            "dependencies": [],
            "details": "The endpoint should accept a JSON body with `email` and `password`. Implement validation: email must be a valid format and not already exist; password must meet complexity requirements (e.g., min 8 characters). Use a strong hashing algorithm like bcrypt to hash the password before saving. Return a success message and a 201 status code upon successful registration.",
            "status": "pending",
            "testStrategy": "Write integration tests for: 1) successful registration with valid data, 2) attempting to register with an existing email, 3) attempting to register with an invalid email format, 4) attempting to register with a weak password."
          },
          {
            "id": 3,
            "title": "Create User Login API Endpoint and Generate JWT",
            "description": "Develop a public API endpoint (e.g., POST /api/auth/login) for user authentication. Upon successful login, generate and return a JSON Web Token (JWT).",
            "dependencies": [],
            "details": "The endpoint should accept `email` and `password`. Find the user by email in the database. Use bcrypt's compare function to verify the provided password against the stored hash. If credentials are valid, generate a JWT containing the user's ID and an expiration date. Return the JWT in the response body.",
            "status": "pending",
            "testStrategy": "Write integration tests for: 1) successful login with correct credentials, 2) login attempt with an incorrect password, 3) login attempt with a non-existent email. Verify the returned JWT contains the correct payload."
          },
          {
            "id": 4,
            "title": "Develop JWT Authentication Middleware for Protected Routes",
            "description": "Create a middleware that intercepts requests to protected routes, validates the JWT from the Authorization header, and attaches the authenticated user's information to the request object.",
            "dependencies": [],
            "details": "The middleware should extract the token from the 'Authorization: Bearer <token>' header. Verify the token's signature using the secret key and check for expiration. If valid, decode the payload to get the user ID, fetch the user from the database, and attach it to the request context (e.g., `req.user`). If the token is invalid or missing, return a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Create a dummy protected endpoint. Write integration tests to access it: 1) with a valid JWT (expect success), 2) without a JWT (expect 401), 3) with an invalid/malformed JWT (expect 401), 4) with an expired JWT (expect 401)."
          }
        ]
      },
      {
        "id": 12,
        "title": "Phase 3: Implement AES-256 Encryption for API Key",
        "description": "Securely store the user's OpenAI API key by encrypting it before saving it to the SQLite database.",
        "details": "Replace the unencrypted storage from Task 10. When the user saves their API key, encrypt it using AES-256 and store the encrypted string in the `users` table. Decrypt it only when needed for an API call.",
        "testStrategy": "Save an API key, inspect the SQLite database to confirm the stored value is an encrypted string, not plaintext. Verify that summarization still works.",
        "priority": "high",
        "dependencies": [
          10,
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the database table(s) to store user information, including username, email, hashed password, and timestamps.",
            "dependencies": [],
            "details": "Define a 'users' table with columns: id (primary key, auto-increment), email (unique, not null), password_hash (string, not null), created_at (timestamp), and updated_at (timestamp). Use a database migration tool to apply the schema.",
            "status": "pending",
            "testStrategy": "Verify the table and its columns are created correctly in the database. Test constraints like 'unique' on the email column by attempting to insert duplicate data and asserting failure."
          },
          {
            "id": 2,
            "title": "Implement Secure Password Hashing Service",
            "description": "Create utility functions to securely hash passwords upon user registration and verify them during login.",
            "dependencies": [],
            "details": "Use a strong, salted hashing algorithm like bcrypt. Create two functions: `hashPassword(plainTextPassword)` which returns a hash, and `comparePassword(plainTextPassword, hashedPassword)` which returns a boolean. Ensure a proper salt round is configured (e.g., 12).",
            "status": "pending",
            "testStrategy": "Write unit tests to confirm that `hashPassword` produces a valid, non-repeating hash for the same input. Test that `comparePassword` correctly returns true for a matching password and false for a non-matching one."
          },
          {
            "id": 3,
            "title": "Develop User Registration API Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/auth/register) that allows new users to sign up.",
            "dependencies": [],
            "details": "The endpoint should accept email and password. It must validate the input (e.g., password complexity, valid email format), check if the email already exists, hash the password using the service from subtask 2, and save the new user to the database.",
            "status": "pending",
            "testStrategy": "Use integration tests to hit the endpoint. Test the success case (201 Created). Test failure cases like duplicate email (409 Conflict), invalid email format (400 Bad Request), and weak password (400 Bad Request)."
          },
          {
            "id": 4,
            "title": "Implement JWT Generation and Validation Service",
            "description": "Create a service to generate JSON Web Tokens (JWTs) for authenticated users and to validate incoming tokens.",
            "dependencies": [],
            "details": "The generation function should accept a user ID as a payload and sign it with a secret key stored securely in environment variables. The validation function should verify the token's signature and check for expiration. Set a reasonable expiration time (e.g., 1h).",
            "status": "pending",
            "testStrategy": "Write unit tests. Test token generation. Test validation with a valid token, an expired token, a token with an invalid signature, and a malformed token, asserting the correct outcomes for each."
          },
          {
            "id": 5,
            "title": "Develop User Login API Endpoint",
            "description": "Create a public API endpoint (e.g., POST /api/auth/login) for users to authenticate and receive a token.",
            "dependencies": [],
            "details": "The endpoint should accept email and password. It will find the user in the database, use the service from subtask 2 to verify the password, and if successful, generate a JWT using the service from subtask 4 to return to the client in the response body.",
            "status": "pending",
            "testStrategy": "Write integration tests. Test successful login with correct credentials, asserting a 200 OK status and the presence of a JWT in the response. Test failed login attempts with an incorrect password or non-existent user, asserting a 401 Unauthorized status."
          },
          {
            "id": 6,
            "title": "Create Authentication Middleware for Protected Routes",
            "description": "Implement middleware to protect specific API routes, ensuring they are only accessible by authenticated users.",
            "dependencies": [],
            "details": "The middleware will extract the JWT from the 'Authorization: Bearer <token>' header. It will use the JWT validation service from subtask 4 to verify the token. If valid, it attaches the user's ID to the request object and passes control to the next handler. If invalid, it returns a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Create a dummy protected endpoint (e.g., GET /api/profile). Write integration tests to access it with a valid token (should succeed), without a token (should fail with 401), and with an invalid/expired token (should fail with 401)."
          }
        ]
      },
      {
        "id": 13,
        "title": "Phase 3: Implement Summary History",
        "description": "Save every generated summary to the local SQLite database to provide users with a history of their activity.",
        "details": "After each successful summarization, insert a new record into the `summaries` table containing the URL, mode, and the generated content. This does not yet require a UI to view the history.",
        "testStrategy": "Generate several summaries. Inspect the `summaries` table in the SQLite database to confirm that records are being created correctly for each one.",
        "priority": "medium",
        "dependencies": [
          11,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Develop User Authentication API Endpoints",
            "description": "Create the backend API endpoints for user registration, login, and logout. This includes handling password hashing and session management.",
            "dependencies": [],
            "details": "Use a secure password hashing library like bcrypt. Implement JWT (JSON Web Tokens) for session management. Endpoints needed: POST /api/register, POST /api/login, POST /api/logout. The registration endpoint should validate input and check for existing users. The login endpoint should verify credentials and return a JWT.",
            "status": "pending",
            "testStrategy": "Write unit tests for authentication logic (password hashing, token generation). Use an API testing tool like Postman to perform integration tests on the /register and /login endpoints, verifying correct responses and status codes."
          },
          {
            "id": 2,
            "title": "Build Frontend Registration and Login UI",
            "description": "Create the user interface components for the registration and login pages using the chosen frontend framework.",
            "dependencies": [],
            "details": "Develop reusable form components for email and password inputs. Implement client-side validation for immediate user feedback (e.g., required fields, valid email format). Style the forms according to the application's design system. The forms should be ready to be wired up to the backend API.",
            "status": "pending",
            "testStrategy": "Use component testing frameworks like Jest and React Testing Library to test form components in isolation. Perform visual regression testing to ensure UI consistency. Use Storybook to develop and document components against a mocked API contract."
          },
          {
            "id": 3,
            "title": "Integrate Frontend UI with Authentication API",
            "description": "Connect the frontend registration and login forms to the backend API endpoints. Handle API responses, manage user session state, and implement protected routes.",
            "dependencies": [],
            "details": "Use a library like Axios or the native Fetch API to make requests to the backend. On successful login, store the received JWT securely. Implement a global state management solution (e.g., Redux, Context API) to track authentication status. Create a routing guard to protect routes that require authentication.",
            "status": "pending",
            "testStrategy": "Conduct end-to-end testing using Cypress or Playwright to verify the complete user flow: registration, login, accessing a protected page, and logging out. Manually test edge cases like incorrect passwords and session expiration."
          }
        ]
      },
      {
        "id": 14,
        "title": "Phase 4: UI/UX Polish and Refinement",
        "description": "Refine the entire user interface for consistency, clarity, and a better user experience.",
        "details": "Improve styling to feel more native. Add clear loading states and user-friendly error messages for all operations (e.g., network failure, invalid API key, scraping failed). Ensure UI responsiveness is under 100ms.",
        "testStrategy": "Conduct user acceptance testing to gather feedback on the UI. Test various error scenarios to ensure helpful messages are displayed.",
        "priority": "low",
        "dependencies": [
          8,
          9,
          10
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the necessary database tables to store user credentials and profile information securely.",
            "dependencies": [],
            "details": "Create a 'users' table with columns: id (primary key, UUID), email (unique, not null), password_hash (not null), created_at, and updated_at. Use a database migration tool (e.g., Alembic, Flyway, Knex.js) to script and apply the schema changes.",
            "status": "pending",
            "testStrategy": "Verify the migration runs successfully against a test database. Manually inspect the created table schema to ensure all columns, types, and constraints are correct. Write a test to ensure email uniqueness is enforced at the database level."
          },
          {
            "id": 2,
            "title": "Implement Secure Password Hashing Service",
            "description": "Create a reusable service for hashing and verifying passwords using a strong, salted hashing algorithm like bcrypt.",
            "dependencies": [],
            "details": "Create a module with two primary functions: `hashPassword(plainTextPassword)` which returns a promise resolving to a hash, and `comparePassword(plainTextPassword, hash)` which returns a promise resolving to a boolean. Use the bcrypt library with a reasonable cost factor (e.g., 12).",
            "status": "pending",
            "testStrategy": "Write unit tests for the service. Test that `hashPassword` produces a valid hash string. Test that `comparePassword` returns true for the correct password and false for an incorrect one. Ensure it handles non-string inputs gracefully."
          },
          {
            "id": 3,
            "title": "Implement JWT Generation and Validation Service",
            "description": "Create a service to generate JSON Web Tokens (JWTs) on successful login and to validate them for authenticating subsequent requests.",
            "dependencies": [],
            "details": "Use a standard JWT library (e.g., `jsonwebtoken` for Node.js). Create a `generateToken(payload)` function that signs a token with a secret key from environment variables. The payload should include user ID and an expiration time (e.g., '1h'). Create a `verifyToken(token)` function that decodes and validates the token.",
            "status": "pending",
            "testStrategy": "Unit test the service. Ensure `generateToken` creates a correctly structured token. Ensure `verifyToken` successfully validates a good token and throws appropriate errors for expired, malformed, or invalid-signature tokens."
          },
          {
            "id": 4,
            "title": "Create User Registration API Endpoint",
            "description": "Develop a public API endpoint for new users to create an account.",
            "dependencies": [],
            "details": "Implement a `POST /api/auth/register` endpoint. It should accept email and password. Validate input (e.g., password strength, valid email format). Use the Password Hashing Service to hash the password before storing the new user record in the database. Return a 201 Created status with the new user's ID and email.",
            "status": "pending",
            "testStrategy": "Write integration tests to check for successful registration with valid data. Test for correct error handling with duplicate emails (409 Conflict), invalid email formats (400 Bad Request), and weak passwords (400 Bad Request). Verify the user is correctly inserted into the test database with a properly hashed password."
          },
          {
            "id": 5,
            "title": "Create User Login API Endpoint",
            "description": "Develop an API endpoint for users to authenticate and receive an access token.",
            "dependencies": [],
            "details": "Implement a `POST /api/auth/login` endpoint. It should accept email and password. Find the user in the database by email. Use the Password Hashing Service to compare the provided password with the stored hash. If valid, use the JWT Service to generate a token and return it in the response body.",
            "status": "pending",
            "testStrategy": "Write integration tests for successful login with correct credentials, verifying a valid JWT is returned. Test failed login attempts with incorrect passwords and non-existent users, ensuring a generic 401 Unauthorized error is returned to prevent user enumeration."
          },
          {
            "id": 6,
            "title": "Implement Authentication Middleware for Protected Routes",
            "description": "Create middleware to protect specific API routes, ensuring only authenticated users can access them.",
            "dependencies": [],
            "details": "The middleware should extract the JWT from the `Authorization: Bearer <token>` header. Use the JWT Service to verify the token. If valid, attach the decoded payload (containing user ID) to the request object (e.g., `req.user`) and pass control to the next handler. If invalid or missing, return a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Create a dummy protected endpoint (e.g., `GET /api/profile`). Write integration tests to verify that requests with a valid token are allowed (200 OK), while requests with no token, an invalid token, or an expired token are rejected with a 401 Unauthorized status code."
          },
          {
            "id": 7,
            "title": "Integrate Authentication with Frontend Forms",
            "description": "Build the UI components for login and registration and connect them to the backend API endpoints.",
            "dependencies": [],
            "details": "Create Login and Register page components with forms. On form submission, make API calls to the `/api/auth/login` or `/api/auth/register` endpoints. On successful login, store the received JWT securely (e.g., in an HttpOnly cookie) and redirect the user to a protected dashboard page. Display appropriate error messages from the API on failure.",
            "status": "pending",
            "testStrategy": "Use an end-to-end testing framework like Cypress or Playwright. Test the full user flow: registering a new user, logging in with those credentials, storing the token, and successfully accessing a protected route. Test that UI error messages are displayed for failed login/registration attempts."
          }
        ]
      },
      {
        "id": 15,
        "title": "Phase 4: Application Packaging and Distribution",
        "description": "Package the application into distributable installers for Windows, macOS, and Linux.",
        "details": "Use Electron's packaging tools (e.g., electron-builder) to create native installers (.exe, .dmg, .deb/AppImage). Write a simple README and user guide for installation and usage.",
        "testStrategy": "Build the installers for each target OS. Perform a clean installation on each platform and run through the primary user flow to ensure it works correctly.",
        "priority": "low",
        "dependencies": [
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Implement User Database Schema",
            "description": "Create the necessary database table to store user information, including credentials and profile data.",
            "dependencies": [],
            "details": "Create a 'users' table with columns: id (primary key, auto-increment), email (unique, indexed), password_hash (string), created_at (timestamp), and updated_at (timestamp). Use a database migration tool to version control the schema.",
            "status": "pending",
            "testStrategy": "Verify the table and its columns are created correctly in the development database. Write a unit test for the User model to ensure it can be instantiated and saved without errors."
          },
          {
            "id": 2,
            "title": "Develop User Registration API Endpoint",
            "description": "Implement the server-side endpoint that allows a new user to create an account.",
            "dependencies": [],
            "details": "Create a `POST /api/auth/register` endpoint. It must validate incoming data (email format, password strength). Use a strong hashing algorithm like bcrypt to hash the user's password before storing it in the database. Return a success status or user object (without the password hash) on successful creation.",
            "status": "pending",
            "testStrategy": "Write integration tests to cover: successful registration, registration with a duplicate email, and registration with invalid input (e.g., weak password, invalid email format). Assert correct HTTP status codes and response bodies."
          },
          {
            "id": 3,
            "title": "Develop User Login API Endpoint with JWT Generation",
            "description": "Implement the server-side endpoint for user login, which returns a JSON Web Token (JWT) upon successful authentication.",
            "dependencies": [],
            "details": "Create a `POST /api/auth/login` endpoint. It should find the user by email, compare the provided password with the stored hash using bcrypt. If credentials are valid, generate a signed JWT containing the user ID and an expiration date. Return the JWT in the response body.",
            "status": "pending",
            "testStrategy": "Write integration tests for: successful login with correct credentials, failed login with an incorrect password, and failed login for a non-existent user. Verify the structure and signature of the returned JWT."
          },
          {
            "id": 4,
            "title": "Implement Authentication Middleware for Protected Routes",
            "description": "Create a middleware function to verify the JWT on incoming requests to protected API routes.",
            "dependencies": [],
            "details": "The middleware should extract the JWT from the `Authorization: Bearer <token>` header. It must verify the token's signature and check for expiration. If the token is valid, decode the payload and attach the user's identity to the request object (e.g., `req.user`). If invalid, it must return a 401 Unauthorized error.",
            "status": "pending",
            "testStrategy": "Write unit tests for the middleware logic, covering cases with a valid token, an invalid token, an expired token, and no token provided. Assert that the request is passed to the next handler or rejected appropriately."
          },
          {
            "id": 5,
            "title": "Create a Sample Protected API Route",
            "description": "Implement an example API route that is protected by the authentication middleware to test the end-to-end authentication flow.",
            "dependencies": [],
            "details": "Create a `GET /api/user/profile` endpoint. Apply the authentication middleware created in the previous task. The route handler should access the user information from the request object (e.g., `req.user.id`) and return non-sensitive profile data for that user.",
            "status": "pending",
            "testStrategy": "Write an integration test that makes a request to the protected route with a valid JWT and asserts a 200 OK response with the correct user data. Write another test that makes a request without a JWT and asserts a 401 Unauthorized response."
          },
          {
            "id": 6,
            "title": "Build Frontend Login and Registration UI Components",
            "description": "Create the user interface components for the login and registration forms that interact with the backend API.",
            "dependencies": [],
            "details": "Using a frontend framework, create 'LoginForm' and 'RegisterForm' components. The forms should handle user input, perform client-side validation, and make API calls to the respective endpoints on submission. On successful login, the received JWT should be stored securely (e.g., in an HttpOnly cookie or local storage).",
            "status": "pending",
            "testStrategy": "Use an end-to-end testing tool like Cypress or Playwright. Create test scripts to simulate a user registering, logging in, and being denied access to a protected page before login, and granted access after login. Verify UI feedback for errors and success states."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-08T13:54:05.048Z",
      "updated": "2025-08-08T15:04:57.562Z",
      "description": "Tasks for master context"
    }
  }
}